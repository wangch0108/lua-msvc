# Lua 编译器中的运算符优先级与短路求值

本文档详细分析 Lua 编译器如何处理运算符优先级和短路求值逻辑，包括完整的数据流和代码生成过程。

---

## 目录

1. [运算符优先级表](#运算符优先级表)
2. [表达式解析核心算法](#表达式解析核心算法)
3. [短路求值机制](#短路求值机制)
4. [完整数据流分析](#完整数据流分析)
5. [字节码生成示例](#字节码生成示例)

---

## 运算符优先级表

### 优先级定义

Lua 编译器在 `lparser.c:1237-1251` 中定义了所有二元运算符的优先级：

```c
static const struct {
  lu_byte left;  /* 左优先级 */
  lu_byte right; /* 右优先级 */
} priority[] = {  /* ORDER OPR */
   {10, 10}, {10, 10},           /* '+' '-' */
   {11, 11}, {11, 11},           /* '*' '%' */
   {14, 13},                  /* '^' (右结合) */
   {11, 11}, {11, 11},           /* '/' '//' */
   {6, 6}, {4, 4}, {5, 5},   /* '&' '|' '~' */
   {7, 7}, {7, 7},           /* '<<' '>>' */
   {9, 8},                   /* '..' (右结合) */
   {3, 3}, {3, 3}, {3, 3},   /* ==, <, <= */
   {3, 3}, {3, 3}, {3, 3},   /* ~=, >, >= */
   {2, 2}, {1, 1}            /* and, or */
};

#define UNARY_PRIORITY 12  /* 一元运算符优先级 */
```

### 优先级从高到低总结

| 优先级 | 运算符 | 说明 |
|--------|--------|------|
| 14 (右) | `^` | 幂运算（右结合） |
| 13 | （右结合性的右侧） | |
| 12 | 一元运算符 | `-` `~` `#` `not` |
| 11 | `*` `/` `%` `//` | 乘除类 |
| 10 | `+` `-` | 加减类 |
| 9 (右) | `..` | 字符串连接（右结合） |
| 8 | （右结合性的右侧） | |
| 7 | `<<` `>>` | 位移 |
| 6 | `&` | 按位与 |
| 5 | `~` | 按位异或 |
| 4 | `\|` | 按位或 |
| 3 | `==` `~=` `<` `<=` `>` `>=` | 比较运算 |
| 2 | `and` | 逻辑与 |
| 1 | `or` | 逻辑或 |

### 右结合性

**左优先级 ≠ 右优先级** 表示该运算符是右结合的：

- `^` (幂运算): `{14, 13}` - `2^3^4` 被解析为 `2^(3^4)`
- `..` (连接): `{9, 8}` - `a..b..c` 被解析为 `a..(b..c)`

---

## 表达式解析核心算法

### subexpr() 函数

位置：`lparser.c:1260-1287`

```c
static BinOpr subexpr (LexState *ls, expdesc *v, int limit) {
  BinOpr op;
  UnOpr uop;
  enterlevel(ls);
  uop = getunopr(ls->t.token);
  if (uop != OPR_NOUNOPR) {  /* 一元运算符? */
    int line = ls->linenumber;
    luaX_next(ls);  /* 跳过运算符 */
    subexpr(ls, v, UNARY_PRIORITY);  /* 递归，优先级=12 */
    luaK_prefix(ls->fs, uop, v, line);
  }
  else simpleexp(ls, v);  /* 简单表达式 */

  /* 只要运算符优先级高于 limit，就继续处理 */
  op = getbinopr(ls->t.token);
  while (op != OPR_NOBINOPR && priority[op].left > limit) {
    expdesc v2;
    BinOpr nextop;
    int line = ls->linenumber;
    luaX_next(ls);  /* 跳过运算符 */
    luaK_infix(ls->fs, op, v);  /* 处理左操作数 */
    /* 用右优先级递归解析右操作数 */
    nextop = subexpr(ls, &v2, priority[op].right);
    luaK_posfix(ls->fs, op, v, &v2, line);  /* 生成代码 */
    op = nextop;
  }
  leavelevel(ls);
  return op;  /* 返回第一个未处理的运算符 */
}
```

### 算法核心思想

**递归下降解析** 的经典实现：

1. **解析左操作数**：检查一元运算符，递归调用 `subexpr(ls, v, UNARY_PRIORITY)`
2. **循环处理二元运算符**：当运算符优先级 > limit 时继续
3. **每个运算符分三步**：
   - `luaK_infix()` - 处理左操作数（短路求值的关键）
   - `subexpr()` - 递归解析右操作数（传入右优先级）
   - `luaK_posfix()` - 生成最终代码

### 为什么需要 left 和 right 优先级？

```
示例：a + b * c

解析过程：
1. 解析 a，遇到 +
2. + 的左优先级是 10，当前 limit=0，10>0，进入处理
3. 调用 luaK_infix(OPR_ADD, a)
4. 递归解析右操作数：subexpr(v2, +的右优先级=10)
5. 解析 b，遇到 *
6. * 的左优先级是 11，当前 limit=10，11>10，进入处理
7. 调用 luaK_infix(OPR_MUL, b)
8. 递归解析右操作数：subexpr(v3, *的右优先级=11)
9. 解析 c，遇到运算符或结束
10. * 的右优先级 11，下一个运算符优先级不大于 11，退出内层循环
11. 返回到外层，+ 的右优先级 10，下一个运算符优先级不大于 10，退出
```

---

## 短路求值机制

### 短路求值的语义

```lua
a and b   -- 如果 a 为 false，返回 a，不计算 b
a or b    -- 如果 a 为 true，返回 a，不计算 b
```

### 实现机制：跳转列表

Lua 使用 expdesc 结构中的两个跳转列表来表示条件表达式：

```c
typedef struct expdesc {
  expkind k;
  union { ... } u;
  int t;  /* true 时跳转列表（条件为真时跳转） */
  int f;  /* false 时跳转列表（条件为假时跳转） */
} expdesc;
```

### luaK_infix() - 处理左操作数

位置：`lcode.c:1636-1678`

```c
void luaK_infix (FuncState *fs, BinOpr op, expdesc *v) {
  luaK_dischargevars(fs, v);
  switch (op) {
    case OPR_AND: {
      luaK_goiftrue(fs, v);  /* 只有 v 为真才继续 */
      break;
    }
    case OPR_OR: {
      luaK_goiffalse(fs, v);  /* 只有 v 为假才继续 */
      break;
    }
    // ... 其他运算符
  }
}
```

### luaK_goiftrue() - "为真则继续"

位置：`lcode.c:1134-1155`

```c
void luaK_goiftrue (FuncState *fs, expdesc *e) {
  int pc;
  luaK_dischargevars(fs, e);
  switch (e->k) {
    case VJMP: {  /* 已有跳转 */
      negatecondition(fs, e);  /* 取反条件 */
      pc = e->u.info;
      break;
    }
    case VK: case VKFLT: case VKINT: case VKSTR: case VTRUE: {
      pc = NO_JUMP;  /* 总是真，不需要跳转 */
      break;
    }
    default: {
      pc = jumponcond(fs, e, 0);  /* 为假时跳转 */
      break;
    }
  }
  luaK_concat(fs, &e->f, pc);  /* 将新跳转加入 false 列表 */
  luaK_patchtohere(fs, e->t);  /* true 列表跳到当前位置 */
  e->t = NO_JUMP;
}
```

**语义解释**：
- `e->f` (false列表) = 如果条件为假，要跳转的位置
- `e->t` (true列表) = 如果条件为真，要跳转的位置
- 对于 `and`：左操作数为假时跳过右操作数

### luaK_goiffalse() - "为假则继续"

位置：`lcode.c:1161-1181`

```c
void luaK_goiffalse (FuncState *fs, expdesc *e) {
  int pc;
  luaK_dischargevars(fs, e);
  switch (e->k) {
    case VJMP: {
      pc = e->u.info;  /* 已有跳转 */
      break;
    }
    case VNIL: case VFALSE: {
      pc = NO_JUMP;  /* 总是假，不需要跳转 */
      break;
    }
    default: {
      pc = jumponcond(fs, e, 1);  /* 为真时跳转 */
      break;
    }
  }
  luaK_concat(fs, &e->t, pc);  /* 将新跳转加入 true 列表 */
  luaK_patchtohere(fs, e->f);  /* false 列表跳到当前位置 */
  e->f = NO_JUMP;
}
```

### luaK_posfix() - 合并跳转列表

位置：`lcode.c:1705-1779`

```c
void luaK_posfix (FuncState *fs, BinOpr opr,
                  expdesc *e1, expdesc *e2, int line) {
  luaK_dischargevars(fs, e2);
  if (foldbinop(opr) && constfolding(fs, opr + LUA_OPADD, e1, e2))
    return;  /* 常量折叠 */
  switch (opr) {
    case OPR_AND: {
      lua_assert(e1->t == NO_JUMP);  /* 已被 luaK_infix 关闭 */
      luaK_concat(fs, &e2->f, e1->f);  /* 合并 false 列表 */
      *e1 = *e2;
      break;
    }
    case OPR_OR: {
      lua_assert(e1->f == NO_JUMP);  /* 已被 luaK_infix 关闭 */
      luaK_concat(fs, &e2->t, e1->t);  /* 合并 true 列表 */
      *e1 = *e2;
      break;
    }
    // ... 其他运算符
  }
}
```

---

## 完整数据流分析

### 示例 1：`a and b`

#### 代码位置：`lparser.c:1260-1287` + `lcode.c:1636-1678`

```
表达式：local x = a and b

假设 a 是局部变量（寄存器 0），b 是局部变量（寄存器 1）

1. [subexpr(limit=0)] 入口，准备解析 a and b

2. [getunopr(TK_NAME)] 返回 OPR_NOUNOPR

3. [simpleexp()] 解析 a
   - a->k = VLOCAL
   - a->u.var.vidx = 0

4. [getbinopr(TK_AND)] 返回 OPR_AND

5. [priority[OPR_AND].left = 2] > limit=0，进入 while 循环

6. [luaX_next()] 跳过 'and'，token 变为 b

7. [luaK_infix(OPR_AND, a)]
   进入 lcode.c:1636

   8. [luaK_dischargevars(a)]
      - a->k: VLOCAL → VNONRELOC
      - a->u.info = 0

   9. 进入 ***OPR_AND*** 分支

  10. [luaK_goiftrue(a)]
      进入 lcode.c:1134

  11. [luaK_dischargevars(a)] 已经是 VNONRELOC

  12. 进入 default 分支

  13. [jumponcond(a, cond=0)]
      - cond=0 表示"为假时跳转"

  14. [discharge2anyreg(a)] 确保 a 在寄存器

  15. [freeexp(a)]

  16. [condjump(OP_TESTSET, NO_REG, a->u.info=0, 0, cond=0)]
      - 生成指令: TESTSET R[0], R[0], 0
      - 如果 R[0] 为假，跳过下一条
      - pc = 5（假设）

  17. 返回 pc = 5

  18. [luaK_concat(&a->f, 5)]
      - a->f = 5（false 列表）

  19. [luaK_patchtohere(a->t)]
      - a->t = NO_JUMP（true 列表为空）

  20. [luaK_goiftrue] 返回，a->f = 5, a->t = NO_JUMP

21. [luaK_infix] 返回

22. [subexpr(&b, priority[OPR_AND].right = 2)] 递归解析右操作数

  23. [getunopr(TK_NAME)] 返回 OPR_NOUNOPR

  24. [simpleexp()] 解析 b
      - b->k = VLOCAL
      - b->u.var.vidx = 1

  25. [getbinopr(TK_...)] 假设没有更多运算符

  26. [priority[OPR_NOBINOPR] = 0] 不 > limit=2，退出 while

  27. 返回 OPR_NOBINOPR

28. [luaK_posfix(OPR_AND, a, b)]
   进入 lcode.c:1705

  29. [luaK_dischargevars(b)]
      - b->k: VLOCAL → VNONRELOC
      - b->u.info = 1

  30. 进入 ***OPR_AND*** 分支

  31. [lua_assert(e1->t == NO_JUMP)] 验证通过

  32. [luaK_concat(&e2->f, e1->f)]
      - b->f = concat(b->f, a->f)
      - b->f = concat(NO_JUMP, 5) = 5

  33. [*e1 = *e2]
      - a->k = b->k = VNONRELOC
      - a->u.info = b->u.info = 1
      - a->f = b->f = 5
      - a->t = b->t = NO_JUMP

34. [luaK_posfix] 返回

35. [subexpr] 返回 OPR_NOBINOPR

最终状态：
- a->k = VNONRELOC
- a->u.info = 1（结果在 R[1]，即 b）
- a->f = 5（如果 a 为假，跳转到 pc=5）
- a->t = NO_JUMP
```

#### 生成的字节码

```
[0] ... (之前的代码)
[5] TESTSET   R[1], R[0], 0    ; 如果 R[0] 为假，跳到 [7]
[6] RETURN    R[1], 2          ; 返回 R[1] (b 的值)
[7] ... (a 为假时的处理)
```

### 示例 2：`a or b and c`

#### 优先级分析

```
a or b and c

由于 and (2) > or (1)，解析为：
a or (b and c)

等价于：
if a then
    return a
else
    return b and c
end
```

#### 完整调用链

```
1. [subexpr(limit=0)] 解析 a or b and c

2. 解析 a（简单表达式）
   - a->k = VNONRELOC

3. 遇到 'or'，getbinopr() = OPR_OR

4. priority[OPR_OR].left = 2 > limit=0，进入循环

5. [luaK_infix(OPR_OR, a)]

   6. [luaK_goiffalse(a)]
      - 如果 a 为真则继续（短路）

   7. [jumponcond(a, cond=1)]
      - 生成 TESTSET，a 为真时跳转

   8. a->t = 跳转位置（a 为真时跳到这里）
   9. a->f = NO_JUMP

10. [subexpr(&b, priority[OPR_OR].right = 1)]

    11. 解析 b（简单表达式）
        - b->k = VNONRELOC

    12. 遇到 'and'，getbinopr() = OPR_AND

    13. priority[OPR_AND].left = 2 > limit=1，进入内层循环

    14. [luaK_infix(OPR_AND, b)]

        15. [luaK_goiftrue(b)]
             - 如果 b 为假则继续（短路）

        16. [jumponcond(b, cond=0)]
             - 生成 TESTSET，b 为假时跳转

        17. b->f = 跳转位置（b 为假时跳到这里）
        18. b->t = NO_JUMP

    19. [subexpr(&c, priority[OPR_AND].right = 2)]

        20. 解析 c（简单表达式）
            - c->k = VNONRELOC

        21. 没有更多运算符，返回

    22. [luaK_posfix(OPR_AND, b, c)]

        23. [luaK_concat(&c->f, b->f)]
             - 合并 false 列表

        24. b = c（b 的结果是 c）

    25. 返回 nextop（无更多运算符）

26. [luaK_posfix(OPR_OR, a, b)]

    27. [luaK_assert(a->f == NO_JUMP)] 验证通过

    28. [luaK_concat(&b->t, a->t)]
         - 合并 true 列表

    29. a = b（a 的结果是 b）

30. 返回
```

#### 生成的字节码

```
[0] TESTSET   R[2], R[0], 0    ; a 为真? 如果是跳到 [3]
[1] TESTSET   R[2], R[1], 0    ; b 为真? 如果是跳到 [3]
[2] LOADTRUE  R[2]             ; b 为假，c 为真
[3] RETURN    R[2], 2          ; 返回结果
```

---

## 字节码生成示例

### 示例 1：短路求值 `local x = a and b`

#### Lua 代码
```lua
local a = true
local b = false
local x = a and b
return x
```

#### 字节码
```
[0] LOADTRUE  R[0]             ; a = true
[1] LOADFALSE R[1]             ; b = false
[2] TESTSET   R[2], R[0], 0    ; 测试 R[0]，为假则跳到 [4]
[3] MOVE      R[2], R[1]       ; R[2] = R[1] (b)
[4] RETURN    R[2], 2          ; 返回 R[2]
```

#### 执行流程
1. R[0] = true
2. R[1] = false
3. TESTSET R[2], R[0], 0：R[0] 为真，不跳转
4. MOVE R[2], R[1]：R[2] = false
5. 返回 false

### 示例 2：短路求值 `local x = a or b`

#### Lua 代码
```lua
local a = false
local b = true
local x = a or b
return x
```

#### 字节码
```
[0] LOADFALSE R[0]             ; a = false
[1] LOADTRUE  R[1]             ; b = true
[2] TESTSET   R[2], R[0], 1    ; 测试 R[0]，为真则跳到 [4]
[3] MOVE      R[2], R[1]       ; R[2] = R[1] (b)
[4] RETURN    R[2], 2          ; 返回 R[2]
```

#### 执行流程
1. R[0] = false
2. R[1] = true
3. TESTSET R[2], R[0], 1：R[0] 为假，不跳转
4. MOVE R[2], R[1]：R[2] = true
5. 返回 true

### 示例 3：复杂的短路求值 `local x = a or b and c`

#### Lua 代码
```lua
local a = false
local b = false
local c = true
local x = a or b and c
return x
```

#### 字节码
```
[0] LOADFALSE R[0]             ; a = false
[1] LOADFALSE R[1]             ; b = false
[2] LOADTRUE  R[2]             ; c = true
[3] TESTSET   R[3], R[0], 1    ; a 为真? 否，继续
[4] TESTSET   R[3], R[1], 0    ; b 为真? 否，继续
[5] MOVE      R[3], R[2]       ; R[3] = R[2] (c)
[6] RETURN    R[3], 2          ; 返回 R[3]
```

#### 执行流程
1. a = false, b = false, c = true
2. TESTSET R[3], R[0], 1：R[0] 为假，不跳转，继续
3. TESTSET R[3], R[1], 0：R[1] 为假，不跳转，继续
4. MOVE R[3], R[2]：R[3] = true
5. 返回 true

### 示例 4：运算符优先级 `local x = a + b * c`

#### Lua 代码
```lua
local a = 2
local b = 3
local c = 4
local x = a + b * c
return x
```

#### 字节码
```
[0] LOADI     R[0], 2           ; a = 2
[1] LOADI     R[1], 3           ; b = 3
[2] LOADI     R[2], 4           ; c = 4
[3] MUL       R[3], R[1], R[2]  ; R[3] = R[1] * R[2] = 12
[4] ADDI      R[4], R[0], 12    ; R[4] = R[0] + 12 = 14
[5] RETURN    R[4], 2           ; 返回 14
```

注意：由于 12 是常量，编译器使用了 ADDI 而不是 ADD。

### 示例 5：右结合运算 `local x = 2 ^ 3 ^ 2`

#### Lua 代码
```lua
local x = 2 ^ 3 ^ 2
return x
```

#### 字节码（解析为 2 ^ (3 ^ 2)）
```
[0] LOADI     R[0], 2           ; 2
[1] LOADI     R[1], 3           ; 3
[2] LOADI     R[2], 2           ; 2
[3] POW       R[3], R[1], R[2]  ; R[3] = 3 ^ 2 = 9
[4] POW       R[4], R[0], R[3]  ; R[4] = 2 ^ 9 = 512
[5] RETURN    R[4], 2           ; 返回 512
```

---

## 关键函数总结

### lparser.c 中的函数

| 函数 | 功能 |
|------|------|
| `getunopr(int op)` | 将 token 转换为一元运算符 |
| `getbinopr(int op)` | 将 token 转换为二元运算符 |
| `subexpr(ls, v, limit)` | 核心表达式解析函数，处理优先级和短路求值 |

### lcode.c 中的函数

| 函数 | 功能 |
|------|------|
| `luaK_infix(fs, op, v)` | 处理二元运算的左操作数 |
| `luaK_posfix(fs, op, e1, e2)` | 处理二元运算的右操作数并生成代码 |
| `luaK_goiftrue(fs, e)` | 为真则继续（用于 and） |
| `luaK_goiffalse(fs, e)` | 为假则继续（用于 or） |
| `jumponcond(fs, e, cond)` | 生成条件跳转指令 |
| `luaK_concat(fs, list, jump)` | 合并跳转列表 |
| `luaK_patchtohere(fs, list)` | 修补跳转目标 |

---

## 总结

### 运算符优先级处理

1. **优先级表**：每个运算符有左右两个优先级
2. **递归下降**：使用 subexpr() 函数递归解析
3. **右结合性**：通过 left > right 实现（如 ^ 和 ..）

### 短路求值机制

1. **跳转列表**：expdesc 中的 t 和 f 字段
2. **AND 实现**：
   - luaK_infix: 调用 luaK_goiftrue，设置 false 列表
   - luaK_posfix: 合并 false 列表到右操作数
3. **OR 实现**：
   - luaK_infix: 调用 luaK_goiffalse，设置 true 列表
   - luaK_posfix: 合并 true 列表到右操作数

### 关键数据结构

```c
// 表达式描述符
typedef struct expdesc {
  expkind k;         /* 表达式类型 */
  union { ... } u;   /* 值 */
  int t;             /* true 时跳转的指令位置 */
  int f;             /* false 时跳转的指令位置 */
} expdesc;

// 运算符优先级
static const struct {
  lu_byte left;      /* 左结合优先级 */
  lu_byte right;     /* 右结合优先级 */
} priority[];
```

### 设计亮点

1. **优雅的递归下降**：简洁的代码处理复杂的优先级
2. **延迟跳转修补**：先生成跳转指令，后续再修补目标地址
3. **常量折叠优化**：编译期计算常量表达式
4. **链式跳转列表**：高效管理多个跳转点
