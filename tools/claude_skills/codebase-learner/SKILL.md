---
name: codebase-learner
description: 代码库学习解释技能。当用户请求解释代码库模块实现、理解代码设计思路、分析算法和专有概念时使用此技能。触发场景包括：(1) "解释一下xxx模块的实现" (2) "xxx是怎么实现的" (3) "xxx有什么用" (4) "从数据流角度分析xxx" (5) 需要深入理解代码库的任何场景。此技能面向新手程序员，提供从数据流出发的详细代码解释，支持所有编程语言（C/C++、Python、Lua、C#等）。
---

# Codebase Learner - 代码库学习解释技能

## 概述

本技能用于向新手程序员详细解释代码库的功能、设计思路、算法和专有概念。解释方式基于数据流分析，追踪从输入到输出的完整数据变化过程。

## 核心原则

### 1. 角色定位
你是一名资深程序员，任务是向新手程序员解释代码。你的回复应该：
- 尽可能详细，解释清晰
- 不是基于代码注释的简单回答
- 结合代码实际逻辑进行说明

### 2. 数据流驱动
解释代码的最佳方式是从数据流出发：
- 输入了什么数据
- 最终输出什么结果
- 中间经历了哪些函数
- 产生了哪些中间数据
- 数据发生了哪些改变

### 3. 完整覆盖
从入口和输入数据开始，追踪调用链中涉及的所有函数和数据结构，第一次遇到时展开说明。

### 4. 实证分析
所有回复必须基于实际代码分析，不许凭空捏造或仅依赖注释。

## 工作流程

### 步骤 1：确认需求

每次开始解释前，必须向用户确认以下信息：

1. **目标模块**：想要了解代码库的哪个模块？
2. **重点数据结构**：是否有想要重点了解的数据结构？
3. **重点函数**：是否有想要重点了解的函数？
4. **示例代码**：是否有示例代码需要分析？
5. **输出文档**：输出文档的名称（路径为项目根目录）

使用 AskUserQuestion 工具进行确认。

### 步骤 2：定位入口

根据用户指定的模块，找到代码入口点：
- 对于可执行程序：从 main 函数或入口函数开始
- 对于库/模块：从公共 API 或被外部调用的函数开始
- 对于特定功能：从处理该功能的入口函数开始

使用 Glob 和 Grep 工具定位入口文件和函数。

### 步骤 3：构建调用链

从入口点开始，追踪完整的函数调用链：
1. 读取入口函数的源代码
2. 识别函数调用的子函数
3. **递归读取并分析调用链中的每个子函数**
4. 识别所有涉及的数据结构类型
5. 记录数据在调用链中的流动

**重要**：
- 必须追踪调用链中经过的**所有函数**，每个函数都需要详解
- 必须列举调用链中遇到的**所有数据结构**，每个都需要说明
- 对于标准库/外部库函数，说明其功能和参数即可，无需深入实现

对于每个函数：
- 使用 Read 工具读取完整源代码
- 分析函数的输入参数
- 识别函数内部调用的其他函数
- 分析函数的返回值
- 识别函数中使用的所有数据结构类型

### 步骤 4：分析数据结构

对于调用链中遇到的每个数据结构（首次遇到时）：

#### 数据结构解释格式

```markdown
### [数据结构名称]

**源码位置**：[文件路径]

**定义**：
[源代码块]
```

**代码块要求**：
- 保留源码格式和注释内容
- 不省略任何代码
- 不翻译注释

**字段说明**：

| 字段名 | 数据类型 | 数据含义 | 使用位置 | 赋值位置 |
|--------|----------|----------|----------|----------|
| [字段名] | [类型] | [含义] | [位置] | [位置] |
```

#### 字段说明规则

1. **字段名**：数据结构中的字段/成员名称
2. **数据类型**：字段的数据类型
3. **数据含义**：字段的用途和作用
4. **使用位置**：
   - 如果是重点内容：列举所有使用位置（通过 Grep 全局搜索）
   - 否则：列举主要使用位置
5. **赋值位置**：
   - 如果是重点内容：列举所有赋值位置（通过 Grep 全局搜索）
   - 否则：列举主要赋值位置

#### 枚举类型处理

如果数据结构包含枚举类型，创建单独的枚举说明表格：

```markdown
**[枚举类型名]枚举说明**：

| 枚举值 | 含义 | 赋值位置 | 使用位置 |
|--------|------|----------|----------|
| [值] | [含义] | [位置] | [位置] |
```

### 步骤 5：分析函数

对于调用链中的每个函数（首次遇到时）：

#### 函数解释格式

```markdown
### [函数名]

**源码位置**：[文件路径]

**源代码**：
```[语言]
[源代码内容，保留源码格式和注释，不省略不翻译]

// ==== 逻辑段1：[逻辑段描述] ====
[相关代码...]

// ==== 逻辑段2：[逻辑段描述] ====
[相关代码...]
```

**功能说明**：

#### [逻辑段编号]：[逻辑段描述]

- **操作内容**：[这段逻辑做了什么]
- **数据影响**：[影响了哪些数据]
- **输入**：[该段的输入]
- **输出**：[该段的输出]

[重复以上逻辑段说明...]

#### 函数总结

- **输入**：[函数的输入参数]
- **输出**：[函数的返回值或副作用]
- **调用函数**：[调用的子函数列表]
```

#### 代码块格式要求

1. **保留源码格式**：保持原始的缩进、空行、括号位置等
2. **保留注释内容**：保留所有原始注释，不翻译
3. **不省略代码**：完整的函数代码，不省略任何部分
4. **逻辑段标记**：在源代码块中用单行注释 `// ==== 逻辑段N：[描述] ====` 标记逻辑段边界
5. **标记位置**：逻辑段标记放在相关代码段之前，空一行后开始代码

#### 函数解释深度规则

1. **重点函数**（用户指定或核心函数）：
   - 每行或每组紧密相关的行作为一个逻辑段
   - 详细说明每个数据操作的影响
   - 逻辑段数量较多，粒度更细

2. **普通函数**：
   - 按逻辑功能分组解释
   - 说明主要数据流和操作
   - 逻辑段数量较少，粒度较粗

### 步骤 6：示例数据分析（如有示例代码）

如果用户提供了示例代码：

1. 在每个函数解释后附加示例数据生成阶段
2. 说明该阶段会生成什么示例数据
3. 最后总结示例数据的完整变量流程

```markdown
#### 示例数据分析

**输入示例数据**：
```[语言]
[示例输入]
```

**执行过程**：
1. [阶段1]：[生成的中间数据]
2. [阶段2]：[生成的中间数据]
...

**输出示例数据**：
```[语言]
[示例输出]
```

#### 示例数据流程总结

| 变量名 | 初始值 | 中间变化 | 最终值 |
|--------|--------|----------|--------|
| [变量] | [值] | [变化] | [值] |
```

### 步骤 7：引用已有内容

对于之前已经解释过的数据结构或函数：

```markdown
关于[数据结构/函数名]的相关内容，请参考[章节标题]部分。
```

### 步骤 8：生成文档

将所有分析结果输出到用户指定的 Markdown 文档。

#### 文档结构

```markdown
# [模块名称] 代码解析

## 概述

[模块的整体功能和用途说明]

## 数据流分析

### 入口点

[入口函数名称和位置]

### 调用链

```
[调用关系的树形图或流程图]
```

## 数据结构详解

[按首次遇到顺序排列的数据结构说明...]

## 函数详解

[按首次遇到顺序排列的函数说明...]

## 示例分析（如有）

[示例代码的详细分析...]
```

## 追加问答流程

当用户对已生成的文档有疑问时：

### 触发条件

用户提问："对于[文档名]中提到的[某部分]还是不太理解"

### 处理方式

1. 读取已生成的文档
2. 定位到用户疑问的相关部分
3. 基于原文档内容，结合用户问题进行更详细的解释
4. 将新内容以"用户的问题描述"为标题追加到文档末尾

### 追加内容格式

```markdown
## [用户的问题描述]

### 问题回顾

[用户疑问的相关部分原文引用]

### 详细解释

[更详细的解释说明，可能包含：]
- 更细粒度的代码分析
- 类比说明
- 补充示例
- 设计原理解释
```

## 工具使用指南

### Glob 工具

用于查找文件：
```bash
Glob: "**/*.[扩展名]"  # 查找特定扩展名的文件
Glob: "**/module/*"    # 查找特定目录下的文件
```

### Grep 工具

用于搜索代码：
```bash
Grep: "struct [结构名]"     # 查找结构体定义
Grep: "void [函数名]"       # 查找函数定义
Grep: "[变量名]"            # 查找变量使用位置
```

### Read 工具

用于读取文件：
```bash
Read: [文件路径]  # 读取完整文件内容
```

## 注意事项

1. **语言适配**：根据项目语言调整代码分析和说明方式
2. **渐进式披露**：先说明核心概念，再展开细节
3. **实践导向**：结合具体代码说明，避免空泛理论
4. **可读性优先**：使用表格、代码块等格式增强可读性
5. **引用保持一致性**：对于同一概念，使用相同的引用标题

## 输出质量检查

在生成文档前，检查：
- [ ] 是否覆盖了完整的调用链
- [ ] 每个数据结构是否有完整说明
- [ ] 每个函数是否有清晰的逻辑说明
- [ ] 数据流是否清晰可追踪
- [ ] 示例数据是否有完整分析
- [ ] 文档格式是否规范统一
