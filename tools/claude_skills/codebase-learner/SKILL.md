---
name: codebase-learner
description: 代码库学习解释技能。当用户请求解释代码库模块实现、理解代码设计思路、分析算法和专有概念时使用此技能。触发场景包括：(1) "解释一下xxx模块的实现" (2) "xxx是怎么实现的" (3) "xxx有什么用" (4) "从数据流角度分析xxx" (5) 需要深入理解代码库的任何场景。此技能面向新手程序员，提供从数据流出发的详细代码解释，支持所有编程语言（C/C++、Python、Lua、C#等）。
---

# Codebase Learner - 代码库学习解释技能

## 概述

本技能用于向新手程序员详细解释代码库的功能、设计思路、算法和专有概念。解释方式基于数据流分析，追踪从输入到输出的完整数据变化过程。

## 核心原则

### 1. 角色定位
你是一名资深程序员，任务是向新手程序员解释代码。你的回复应该：
- 尽可能详细，解释清晰
- 不是基于代码注释的简单回答
- 结合代码实际逻辑进行说明

### 2. 数据流驱动
解释代码的最佳方式是从数据流出发：
- 输入了什么数据
- 最终输出什么结果
- 中间经历了哪些函数
- 产生了哪些中间数据
- 数据发生了哪些改变

### 3. 完整覆盖
从入口和输入数据开始，追踪调用链中涉及的所有函数和数据结构，第一次遇到时展开说明。

**重要：展开深度规则**
- **首次调用的函数**：必须完整展开其内部执行流程，包括所有条件分支、循环、子函数调用
- **禁止**：对首次调用的函数使用"调用xx函数获得什么结果"的概述方式
- **允许**：对**已经完整解释过的函数**，可以使用概述方式引用其之前的行为
- **绝对禁止**：因为"篇幅限制"、"token限制"或其他任何原因而简化或省略任何内容

**多语句处理规则**：
- 当示例代码包含多条语句时，**每条语句都必须完整展开**
- 第一条语句：完整展开所有步骤
- 第二条语句：完整展开所有步骤（包括首次调用的函数）
- ...依此类推，**最后一条语句也必须完整展开**
- 禁止使用"由于篇幅限制，后续语句不再展开"之类的表述

**展开深度示例**：
```
正确（首次调用必须展开）：
N. [进入funcA()]
N+1. [funcA()] 调用 funcB()
N+2. [进入funcB()] 首次调用，展开内部流程
N+3. [funcB()] 执行操作X，result = ...
N+4. [回到funcA()] result = ...

错误（首次调用不应概述）：
N. [进入funcA()]
N+1. [funcA()] 调用 funcB() 获得 result  ← 错误！首次调用应展开

正确（非首次调用可以概述）：
N. [进入funcC()]
N+1. [funcC()] 调用 funcB()（已在步骤N+2~N+4解释过）
N+2. [funcC()] funcB() 返回 result
```

### 4. 实证分析
所有回复必须基于实际代码分析，不许凭空捏造或仅依赖注释。

## 工作流程

### 步骤 1：确认需求

每次开始解释前，必须向用户确认以下信息：

1. **目标模块**：想要了解代码库的哪个模块？
2. **重点数据结构**：是否有想要重点了解的数据结构？
3. **重点函数**：是否有想要重点了解的函数？
4. **示例代码**：是否有示例代码需要分析？
5. **输出文档**：输出文档的名称（路径为项目根目录）

使用 AskUserQuestion 工具进行确认。

### 步骤 2：定位入口

根据用户指定的模块，找到代码入口点：
- 对于可执行程序：从 main 函数或入口函数开始
- 对于库/模块：从公共 API 或被外部调用的函数开始
- 对于特定功能：从处理该功能的入口函数开始

使用 Glob 和 Grep 工具定位入口文件和函数。

### 步骤 3：数据流分析

这是本技能的核心部分，以数据流驱动的方式详细追踪代码执行过程。

#### 数据流章节结构

```markdown
## 数据流

### 入口&示例代码

**入口**: [入口函数名] // [源文件]

**示例代码**: `[示例代码片段]`

**前置数据说明**: [如有必要，说明执行前的初始数据状态]

### 调用链

1. [前置数据] [数据状态描述，包含变量和结构的详细内容]
2. [进入函数名()] (参数1(值), 参数2(值), ...)
3. [函数名()] [操作描述]
4. [函数名()] 进入 ***分支名*** 分支, 调用子函数()
5. [进入子函数()] (参数1(值), 参数2(值))
6. [子函数()] [操作描述，包括数据的变化]
7. [回到函数名()] [返回值或状态变化]
8. [函数名()] 进入 ***另一分支*** 分支, [其他操作]
...

### 调用链树状图

```
statement()                          [入口]
├── exprstat()                       [表达式语句]
│   ├── suffixedexp()                [后缀表达式]
│   │   ├── primaryexp()             [主表达式]
│   │   │   └── singlevar()          [变量查找]
│   │   │       ├── singlevaraux()   [查找局部变量]
│   │   │       └── singlevaraux()   [查找上值]
│   │   └── fieldsel() / [返回]      [字段选择 / 返回]
│   └── restassign()                 [赋值处理]
│       └── explist()                [表达式列表]
│           └── expr()
│               └── simpleexp()
│                   └── constructor() / [直接返回常量]
└── [返回]
```

**树状图说明**：
- 每个缩进层级表示一次函数调用
- `├──` 表示有兄弟节点
- `└──` 表示最后一个子节点
- `[说明]` 表示关键操作或返回点
- `/ [返回]` 或 `└── [返回]` 表示函数返回
```

#### 多语句处理规则

**重要**：当示例代码包含多条语句时：

1. **每条语句都必须完整展开**：
   - 第一条语句：完整展开所有步骤
   - 第二条语句：完整展开所有步骤（包括首次调用的函数）
   - 第三条语句：完整展开所有步骤
   - ...依此类推，最后一条语句也必须完整展开

2. **禁止简化任何语句**：
   - 禁止使用"由于篇幅限制，后续语句不再展开"
   - 禁止使用"类似地，其他语句..."
   - 禁止使用简述或概述的方式跳过任何语句

3. **重复函数的处理**：
   - 如果某条语句调用了之前已完整解释过的函数，可以使用概述方式
   - 如果某条语句调用了首次出现的函数，必须完整展开

**示例（正确）**：
```markdown
#### 第一条语句：local x = 10

1. [前置数据] ...
2. [进入funcA()] ...
...（241步完整展开）

#### 第二条语句：local y = x + 5

242. [前置数据] ...
243. [进入funcB()] ...
...（完整展开所有步骤）
```

**示例（错误）**：
```markdown
#### 第一条语句：local x = 10

1. [前置数据] ...
...（241步完整展开）

由于篇幅限制，后续语句不再展开：
- 第二条：local y = x + 5 → ADD 指令
- 第三条：... ← 错误！必须完整展开
```

#### 调用链格式规则

**编号规则**：
- 使用连续数字编号，从 1 开始
- 每个操作步骤占一行
- 函数调用和返回保持缩进对齐

**标记类型**：

| 标记类型 | 格式 | 说明 | 示例 |
|---------|------|------|------|
| 前置数据 | `[前置数据]` | 进入函数前的初始数据状态 | `[前置数据] LexState第一个token为{ t:TK_NAME }` |
| 进入函数 | `[进入函数名()]` | 进入一个新的函数 | `[进入exprstat()] (LexState* ls)` |
| 函数操作 | `[函数名()]` | 函数内的具体操作 | `[exprstat()] 初始化v, 调用suffixedexp()` |
| 返回上层 | `[回到函数名()]` | 从子函数返回 | `[回到exprstat()] v被填充为VLOCAL` |
| 分支高亮 | `***分支名***` | 进入的代码分支 | `进入 ***default*** 分支` |
| 循环标记 | `[第N次循环]` | 循环的某次迭代 | `[第1次循环] 开始遍历元素` |
| 条件判断 | `[条件满足/不满足]` | 条件分支的判断结果 | `[条件满足] 进入if分支` |

**参数状态追踪**：
- 每次函数调用后，在括号内标注关键参数的当前值
- 格式：`(参数名(值), 参数名(值))`
- 对于指针类型，标注指向的数据内容
- 对于结构体，标注关键字段的值

**数据变化描述**：
- 明确说明数据的变化：初始化、修改、赋值等
- 对于结构体字段变化，使用 `->` 符号：`v->k = VLOCAL`
- 对于变量赋值，使用 `=` 符号：`idx = 0`

**分支高亮规则**：
- 使用 `***分支名***` 格式标注进入的代码分支
- 分支名包括：switch case、if/else、循环等
- 示例：`进入 ***TK_NAME*** 分支`、`进入 ***else*** 分支`

**函数调用展开规则**：
- **首次调用**：必须使用 `[进入函数名()]` 标记，然后完整展开该函数的内部流程
- **内部流程展开**：至少包含以下内容：
  - 函数内的条件判断（if/switch）及进入的分支
  - 循环的迭代过程
  - 所有子函数的首次调用
  - 关键数据的赋值和修改
- **非首次调用**：可以使用概述方式，如 `[函数名()] 调用子函数()（已在步骤X中解释）`

**禁止行为**：
```
禁止（首次调用不应概述）：
N. [函数A()] 调用函数B()获得结果X

正确（首次调用必须展开）：
N. [函数A()] 调用函数B()
N+1. [进入函数B()] (参数(值))
N+2. [函数B()] 执行操作...
N+3. [回到函数A()] 返回值=...
```

#### 最终生成的字节码

当分析涉及代码生成、编译器或虚拟机的模块时，必须在调用链和树状图之后添加"最终生成的字节码"部分，展示编译器生成的最终输出。

**字节码章节格式**：

```markdown
### 最终生成的字节码

```
; [源语句1的注释]
[指令1]                  ; [指令说明]
[指令2]                  ; [指令说明]
...

; [源语句2的注释]
[指令3]                  ; [指令说明]
[指令4]                  ; [指令说明]
...
```
```

**字节码格式规则**：

| 规则 | 说明 | 示例 |
|------|------|------|
| 按语句分组 | 用分号注释标记源语句 | `; t = {}` |
| 指令格式 | 指令名 + 参数 | `NEWTABLE 0 0 0` |
| 指令说明 | 用分号注释说明指令作用 | `; R[0] = {}` |
| 参数含义 | 说明参数的含义 | `A=目标寄存器, B=表索引` |

**字节码内容要求**：

1. **完整展示**：展示所有生成的指令，不得省略
2. **按语句分组**：用 `; 源语句` 注释分隔每条语句生成的指令
3. **指令注释**：每条指令后面必须用 `;` 注释说明其作用
4. **参数说明**：对于复杂指令，在注释中说明各参数的含义

**字节码示例**：

```markdown
### 最终生成的字节码

```
; t = {}
NEWTABLE 0 0 0          ; R[0] = {}（创建空表）
EXTRAARG 0              ; 额外参数（表大小预留）
SETTABUP 0 0 0          ; _ENV["t"] = R[0]（存储到全局变量）

; t.a = 1
GETTABUP 0 0 0          ; R[0] = _ENV["t"]（加载全局变量t）
LOADI 1 1               ; R[1] = 1（加载整数常量）
SETFIELD 0 1 1          ; R[0]["a"] = R[1]（设置字段a）
```
```

**适用场景**：

- 编译器代码生成模块
- 虚拟机字节码执行
- 解释器指令生成
- 任何产生中间代码或目标代码的模块

**不适用的场景**：

- 纯数据处理模块（无代码生成）
- UI 渲染模块（无字节码输出）
- 网络 I/O 模块（无指令生成）

#### 数据流分析深度规则

**重点函数/模块**：
- 每个语句/表达式作为一个步骤
- 详细标注每个变量的变化
- 追踪所有条件判断的分支路径

**普通函数**：
- 按逻辑功能分组，每组作为一个步骤
- 说明主要数据流和关键变化

#### 复杂场景处理

**循环处理**：
```
N. [进入循环()] (循环变量(初始值))
N+1. [循环()] 第1次迭代, 循环变量=当前值
N+2. [循环体内函数()] (参数(值))
N+3. [回到循环()] 循环变量=新值
N+4. [循环()] 第2次迭代, 循环变量=新值
...
N+M. [循环()] 条件不满足, 退出循环
```

**递归处理**：
```
N. [函数名()] 调用自身(参数(值))
N+1. [进入函数名()] 第1层递归 (参数(值))
N+2. [函数名()] 调用自身(参数(新值))
N+3. [进入函数名()] 第2层递归 (参数(新值))
...
N+M. [回到函数名()] 第2层返回 (返回值)
N+M+1. [回到函数名()] 第1层返回 (返回值)
```

**条件分支处理**：
```
N. [函数名()] 判断条件表达式
N+1. [函数名()] [条件满足] 进入 ***then*** 分支
N+2. [分支内操作()] ...
N+3. [回到函数名()] 继续执行
```

**函数调用链处理**（首次调用）：
```
N. [外层函数()] 调用内层函数()
N+1. [进入内层函数()] (参数1(值), 参数2(值))
N+2. [内层函数()] 执行初始化操作
N+3. [内层函数()] 判断条件
N+4. [内层函数()] [条件满足] 进入 ***分支A***
N+5. [内层函数()] 调用子函数()  <- 如果是首次，继续展开
N+6. [进入子函数()] ...
...
N+M. [回到内层函数()] 返回值
N+M+1. [内层函数()] 继续执行后续操作
N+M+2. [回到外层函数()] 获得结果
```

**函数调用链处理**（非首次调用）：
```
N. [外层函数()] 调用内层函数()
N+1. [外层函数()] 内层函数() 返回已知结果（已在步骤X中详细解释）
```

**函数内 switch-case 处理**：
```
N. [函数名()] 根据 e->k 进入对应的 switch 分支
N+1. [函数名()] e->k == VLOCAL，进入 ***VLOCAL*** 分支
N+2. [函数名()] 执行 VLOCAL 分支的操作
N+3. [回到函数名()] switch 结束，继续执行
```

### 步骤 4：分析数据结构

对于调用链中遇到的每个数据结构（首次遇到时）：

#### 数据结构解释格式

```markdown
### [数据结构名称]

**定义**：
```c
// xxx.h (或 xxx.c)
[源代码块]
```

**代码块要求**：
- 保留源码格式和注释内容
- 不省略任何代码
- 不翻译注释

**字段说明**：

| 字段名 | 数据类型 | 数据含义 | 使用位置 | 赋值位置 |
|--------|----------|----------|----------|----------|
| [字段名] | [类型] | [含义] | [位置] | [位置] |
```

#### 字段说明规则

1. **字段名**：数据结构中的字段/成员名称
2. **数据类型**：字段的数据类型
3. **数据含义**：字段的用途和作用
4. **使用位置**：
   - 如果是重点内容：列举所有使用位置（通过 Grep 全局搜索）
   - 否则：列举主要使用位置
5. **赋值位置**：
   - 如果是重点内容：列举所有赋值位置（通过 Grep 全局搜索）
   - 否则：列举主要赋值位置

#### 枚举类型处理

如果数据结构包含枚举类型，创建单独的枚举说明表格：

```markdown
**[枚举类型名]枚举说明**：

| 枚举值 | 含义 | 赋值位置 | 使用位置 |
|--------|------|----------|----------|
| [值] | [含义] | [位置] | [位置] |
```

### 步骤 5：分析函数

对于调用链中的每个函数（首次遇到时）：

#### 函数解释格式

```markdown
### [函数名]

**源码位置**：[文件路径]

**源代码**：
```[语言]
[源代码内容，保留源码格式和注释，不省略不翻译]

// ==== 逻辑段1：[逻辑段描述] ====
[相关代码...]

// ==== 逻辑段2：[逻辑段描述] ====
[相关代码...]
```

**功能说明**：

#### [逻辑段编号]：[逻辑段描述]

- **操作内容**：[这段逻辑做了什么]
- **数据影响**：[影响了哪些数据]
- **输入**：[该段的输入]
- **输出**：[该段的输出]

[重复以上逻辑段说明...]

#### 函数总结

- **输入**：[函数的输入参数]
- **输出**：[函数的返回值或副作用]
- **调用函数**：[调用的子函数列表]
```

#### 代码块格式要求

1. **保留源码格式**：保持原始的缩进、空行、括号位置等
2. **保留注释内容**：保留所有原始注释，不翻译
3. **不省略代码**：完整的函数代码，不省略任何部分
4. **逻辑段标记**：在源代码块中用单行注释 `// ==== 逻辑段N：[描述] ====` 标记逻辑段边界
5. **标记位置**：逻辑段标记放在相关代码段之前，空一行后开始代码

#### 函数解释深度规则

1. **重点函数**（用户指定或核心函数）：
   - 每行或每组紧密相关的行作为一个逻辑段
   - 详细说明每个数据操作的影响
   - 逻辑段数量较多，粒度更细

2. **普通函数**：
   - 按逻辑功能分组解释
   - 说明主要数据流和操作
   - 逻辑段数量较少，粒度较粗

### 步骤 6：示例数据分析（如有示例代码）

如果用户提供了示例代码：

1. 在每个函数解释后附加示例数据生成阶段
2. 说明该阶段会生成什么示例数据
3. 最后总结示例数据的完整变量流程

```markdown
#### 示例数据分析

**输入示例数据**：
```[语言]
[示例输入]
```

**执行过程**：
1. [阶段1]：[生成的中间数据]
2. [阶段2]：[生成的中间数据]
...

**输出示例数据**：
```[语言]
[示例输出]
```

#### 示例数据流程总结

| 变量名 | 初始值 | 中间变化 | 最终值 |
|--------|--------|----------|--------|
| [变量] | [值] | [变化] | [值] |
```

### 步骤 7：引用已有内容

对于之前已经解释过的数据结构或函数：

```markdown
关于[数据结构/函数名]的相关内容，请参考[章节标题]部分。
```

### 步骤 8：生成文档

将所有分析结果输出到用户指定的 Markdown 文档。

#### 文档结构

```markdown
# [模块名称] 代码解析

## 概述

[模块的整体功能和用途说明]

## 数据流

### 入口&示例代码

**入口**: [入口函数名] // [源文件]

**示例代码**: `[示例代码片段]`

**前置数据说明**: [如有必要，说明执行前的初始数据状态]

### 调用链

1. [前置数据] [数据状态描述]
2. [进入函数名()] (参数(值))
3. [函数名()] [操作描述]
...

### 调用链树状图

```
[函数调用层次树状图]
```

**树状图说明**：
- [树状图的结构说明]

### 最终生成的字节码（如有）

```
; [源语句注释]
[指令]    ; [指令说明]
...
```

## 数据结构详解

[按首次遇到顺序排列的数据结构说明...]

## 函数详解

[按首次遇到顺序排列的函数说明...]

## 示例分析（如有）

[示例代码的详细分析...]
```

## 追加问答流程

当用户对已生成的文档有疑问时：

### 触发条件

用户提问："对于[文档名]中提到的[某部分]还是不太理解"

### 处理方式

1. 读取已生成的文档
2. 定位到用户疑问的相关部分
3. 基于原文档内容，结合用户问题进行更详细的解释
4. 将新内容以"用户的问题描述"为标题追加到文档末尾

### 追加内容格式

```markdown
## [用户的问题描述]

### 问题回顾

[用户疑问的相关部分原文引用]

### 详细解释

[更详细的解释说明，可能包含：]
- 更细粒度的代码分析
- 类比说明
- 补充示例
- 设计原理解释
```

## 工具使用指南

### Glob 工具

用于查找文件：
```bash
Glob: "**/*.[扩展名]"  # 查找特定扩展名的文件
Glob: "**/module/*"    # 查找特定目录下的文件
```

### Grep 工具

用于搜索代码：
```bash
Grep: "struct [结构名]"     # 查找结构体定义
Grep: "void [函数名]"       # 查找函数定义
Grep: "[变量名]"            # 查找变量使用位置
```

### Read 工具

用于读取文件：
```bash
Read: [文件路径]  # 读取完整文件内容
```

## 注意事项

1. **语言适配**：根据项目语言调整代码分析和说明方式
2. **渐进式披露**：先说明核心概念，再展开细节
3. **实践导向**：结合具体代码说明，避免空泛理论
4. **可读性优先**：使用表格、代码块等格式增强可读性
5. **引用保持一致性**：对于同一概念，使用相同的引用标题
6. **完整展开**：首次调用的函数必须完整展开其内部流程，禁止用"调用xx函数获得结果"概述首次调用
7. **禁止简化**：**绝对禁止**因为"篇幅限制"、"token限制"或任何其他原因而简化或省略任何内容。所有语句的所有调用链都必须完整展开，无论示例代码有多少条语句

## 输出质量检查

在生成文档前，检查：
- [ ] 是否覆盖了完整的调用链
- [ ] 每个数据结构是否有完整说明
- [ ] 每个首次调用的函数是否完整展开（不是概述）
- [ ] 每个函数的 switch/case/if/else 分支是否明确标注
- [ ] 数据流是否清晰可追踪
- [ ] 示例数据是否有完整分析
- [ ] 文档格式是否规范统一
- [ ] **是否所有语句都完整展开**：检查是否有"由于篇幅限制"、"简化"等字样
- [ ] **是否没有省略任何调用链**：每条语句的每个步骤都必须详细列出
